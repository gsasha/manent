import Container

PREFIX = "repository."

class Repository:
	"""Handles the moving of blocks to and from storages.

	Input: a stream of blocks
	Creates containers and sends them to storage
	
	Data structure:
	block_container_db keeps for each hash the list of sequence_id+container_id
	
	The sequences are numbered globally for all the storages, and are identified
	by a random sequence id generated by the storage automatically
	
	seq_to_index keeps for each sequence id its storage idx an global sequence idx
	index_to_seq keeps for each global sequence idx its storage idx and sequence id
	The information is encoded in config_db.
	
	active_sequence keeps the global idx of the current active sequence. stored in
	config_db["active_sequence"]
	
	storage idxs are stored in the config_db["storage_idxs"]
	"""
	def __init__(self, backup):
		self.backup = backup
		self.config_db = backup.get_private_config_db()
		self.block_container_db = self.backup.get_database(".block-container")
		self.current_open_container = None
		
		# Mapping of storage sequences to indices and vice versa
		# The storage sequence data consists of storage index and sequence
		# ID string
		# In the config_db we store the persistent copy of the information
		# in the seq_to_index and index_to_seq:
		# repo.%index.seq = sequence
		# repo.%index.storage = storage index
		# repo.next_index = <the next index>
		self.seq_to_index = {}
		self.index_to_seq = {}
		self.next_seq_idx = int(self.config_db[PREFIX+"next_seq"])
		for seq_idx in range(self.next_seq_idx):
			seq_id = int(self.config_db[PREFIX+"%d.seq_id"%seq_idx])
			storage_idx = int(self.config_db[PREFIX+"%d.storage_idx"%seq_idx])
			self.seq_to_index[seq_id] = (storage_idx, seq_idx)
			self.index_to_seq[seq_idx] = (storage_idx, seq_id)

		self.active_sequence_idx = self.compute_active_sequence()
		#
		# All storages except for the specified one are inactive, i.e., base.
		# Inactive storages can be used to pull data blocks from, and must
		# be updated on each invocation, since somebody else might be adding
		# blocks there
		#
		self.storages = {}
		for storage_idx in self.get_storage_idxs():
			self.storages[storage_idx] = Storage.load_storage(idx)
	def get_sequence_idx(self, storage_idx, sequence_id):
		if self.seq_to_index.has_key((storage_idx, sequence_id)):
			return self.seq_to_index[(storage_idx, sequence_id)]
		# Generate new index for this sequence
		index = self.next_seq_idx
		self.next_seq_idx += 1
		self.config_db[PREFIX+"next_seq"] = str(self.next_seq_idx)
		self.seq_to_index[(storage_idx, sequence_id)] = index
		self.index_to_seq[index] = (storage_idx, sequence_id)
		return index
	def add_storage(self, storage_type, storage_params):
		# When we add a storage, the following algorithm is executed:
		# 1. If the storage is already in the shared db, it is just added
		# 2. If the storage is not in the shared db, the storage location
		#    is rescanned. All storage locations found there are added as
		#    base storages, and a new one is created.
		storage_idx = max(self.get_storage_idxs()) + 1
		self.write_storage_idxs(self.get_storage_idxs() + [storage_idx])

		storage = Storage.create_storage(storage_type)
		storage.init(storage_idx, storage_params)
		self.storages[storage_idx] = storage
		
		class NewSequenceHandler:
			def __init__(self, repository):
				pass
			def new_sequence(self, sequence):
				repository.new_sequence(sequence)
		storage.scan_containers(NewSequenceHandler(self))
	def get_storage_idxs(self):
		idxs_str = self.config_db[PREFIX+"storage_idxs"]
		storage_idxs = IE.binary_read_int_varlen_list(idxs_str)
		return storage_idxs
	def write_storage_idxs(self, storage_idxs):
		idxs_str = IE.binary_write_int_varlen_list(storage_idxs)
		self.config_db[PREFIX+"storage_idxs"] = idxs_str
	def compute_active_sequence(self):
		KEY = PREFIX + "active_sequence_idx"
		if not self.config_db.has_key(KEY):
			return None
		return int(self.config_db[KEY])
	def is_active_storage(self, storage_idx):
		if self.active_sequence_idx is Null:
			return False
		active_storage_idx, seq_id = self.index_to_seq[active_sequence_idx]
		return active_storage_idx == storage_idx
	def get_storage_config(self, storage_index):
		return self.storages[storage_index].get_config()
	def make_active_storage(self, storage_index):
		if self.active_storage is not None:
			raise Exception("Switching active storage not supported yet")
	def load(self):
		for storage_index in range(int(self.config_db[PREFIX+"next_storage"])):
			storage_type = self.config_db[PREFIX+"storage.%d.type"%storage_index]
	def rescan_storage(self, handler):
		# TODO: this should proceed in a separate thread
		# actually, each storage could be processed in its own thread
		class Handler:
			def __init__(self, handler, storage_idx, sequence_idx):
				self.handler = handler
				self.storage_idx = storage_idx
				self.sequence_idx = sequence_idx
			def loaded(self, digest, data, code):
				self.handler.loaded(self.storage_idx, self.sequence_idx,
					digest, data, code)
		for storage in self.storages():
			# This is not active storage. Somebody else might be updating it,
			# so rescan
			new_containers = storage.rescan()
			for sequence_id, container_idx in new_containers:
				sequence_idx = self.get_sequence_idx(storage_idx, sequence_id)
				container = storage.get_container(container_idx)
				#
				# Register blocks of the container in the block_container_db
				#
				container.load_header()
				has_nondata_blocks = False
				has_data_blocks = False
				encoded = self.encode_block_info(storage_idx, container_idx)
				for digest, size, code in container.list_blocks():
					self.block_container_db[digest] = encoded
					if code != Container.CODE_DATA:
						has_nondata_blocks = True
					else:
						has_data_blocks = True
				#
				# Notify the caller of the nondata blocks, which are supposed
				# to be cached
				#
				if has_nondata_blocks:
					container.load_body()
					container.load_blocks(handler)
				if not has_data_blocks:
					container.remove_files()
	def close(self):
		self.block_container_db.close()
	def add_block(self, digest, data, code):
		storage_idx, seq_id = self.index_to_seq[self.active_seq_idx]
		storage = self.storages[storage_idx]
		#
		# Make sure we have a container that can take this block
		#
		if self.current_open_container is None:
			self.current_open_container = self.storage.open_container()
		if not self.current_open_container.can_add_block(digest, data, code):
			self.write_container(self.current_open_container)
			self.current_open_container = self.storage.open_container()
		#
		# add the block to the container
		#
		self.current_open_container.add_block(digest, data, code)
	def flush(self):
		storage_idx, seq_id = self.index_to_seq[self.active_seq_idx]
		storage = self.storages[storage_idx]

		if self.current_open_container is not None:
			self.write_container(self.current_open_container)
			self.current_open_container = None
	def write_container(self, container):
		container.finalize()
		#
		# Now we have container idx, update it in the blocks db
		#
		container_idx = container.get_idx()
		encoded = self.encode_block_info(self.active_seq_idx, container_idx)
		for digest, code in container.list_blocks():
			self.block_container_db[digest] = encoded
	def load_block(self, digest, handler):
		seq_idx, container_idx = self.decode_block_info(self.block_container_db[digest])
		storage_idx, seq_id = self.index_to_seq[seq_idx]
		storage = self.storages[storage_idx]
		container = storage.get_container(container_idx, seq_id)
		container.load_header()
		container.load_body()
		container.load_blocks(handler)
		container.remove_files()
	def get_block_storage(self, digest):
		seq_idx, container_idx = self.decode_block_info(self.block_container_db[digest])
		storage_idx, seq_id = self.index_to_seq[seq_idx]
		return storage_idx
	#--------------------------------------------------------
	# Utility methods
	#--------------------------------------------------------
	def encode_block_info(self, seq_idx, container_idx):
		io = StringIO()
		Format.write_int(io, seq_idx)
		Format.write_int(io, container_idx)
		return io.value()
	def decode_block_info(self, encoded):
		io = StringIO(encoded)
		seq_idx = Format.read_int(io)
		container_idx = Format.read_int(io)
		return (storage_idx, container_idx)
